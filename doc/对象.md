# 第三部分 对象

### 属性

在对象中，属性名永远都是**字符串**。如果你使用 string（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外

```js
var myObject = {};
myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";
myObject["true"]; // "foo"
myObject["3"]; // "bar"
myObject["[object Object]"]; // "baz"
```

### 可计算属性名

ES6 增加了可计算属性名，可以在文字形式中使用[] 包裹一个表达式来当作属性名：

```js
var prefix = "foo";
var myObject = {
  [prefix + "bar"]: "hello",
};
myObject["foobar"]; // hello
```

### 复制对象

**经典问题**：**深拷贝** & **浅拷贝**

深拷贝： `var newObj = JSON.parse( JSON.stringify( someObj ) )`
浅拷贝：**Object.assign(..)** 方法的第一个参数是**目标对象**，之后还可以跟一个或**多个源对象**。它会遍历一个或多个源对象的所有**可枚举的自有键**并把它们复制（使用= 操作符赋值）到**目标对象**，最后返回目标对象。

**JSON.stringify 深拷贝的缺点**：
1、如果`obj`里面有时间对象，则拷贝后时间将只是字符串的形式，而不是对象的形式；
2、如果`obj`里有`RegExp`、`Error`对象，则序列化的结果将只得到**空对象**；
3、如果`obj`里有函数，`undefined`，则序列化的结果会把**函数**或 `undefined`丢失；
4、如果`obj`里有`NaN`、`Infinity`和`-Infinity`，则序列化的结果会变成`null`
5、`JSON.stringify()`只能序列化对象的**可枚举的自有属性**，例如 如果`obj`中的对象是有构造函数生成的， 则使用`JSON.parse(JSON.stringify(obj))`深拷贝后，会丢弃对象的`constructor`；
6、如果对象中存在**循环引用**的情况也无法正确实现深拷贝。

### 属性描述符

ES5 开始，所有的属性都具备了属性描述符

```js
var myObject = {
  a: 2,
};
Object.getOwnPropertyDescriptor(myObject, "a");
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
```

使用`Object.defineProperty(..)`来添加一个新属性或者修改一个已有属性（如果它是`configurable`）并对特性进行设置。

```js
var myObject = {};
Object.defineProperty(myObject, "a", {
  value: 2,
  writable: true,
  configurable: true,
  enumerable: true,
});
myObject.a; // 2
```

- **Writable**
  **writable** 决定是否可以修改属性的值。
- **Configurable**
  只要属性是可配置的，就可以使用**defineProperty(..)** 方法来修改属性描述符, `configurable:false `还会禁止删除这个属性
- **Enumerable**
  属性是否会出现在对象的属性枚举中，比如说` for..in` 循环。如果把 `enumerable `设置成`false`，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。

### 不变性

- **对象常量**：
  结合`writable:false` 和`configurable:false` 就可以创建一个真正的常量属性（不可修改、重定义或者删除）：

```js
var myObject = {};
Object.defineProperty(myObject, "FAVORITE_NUMBER", {
  value: 42,
  writable: false,
  configurable: false,
});
```

- **禁止扩展**：
  如果你想禁止一个对象添加新属性并且保留已有属性， 可以使用`Object.preventExtensions(..)` ：

```js
var myObject = {
  a: 2,
};
Object.preventExtensions(myObject);
myObject.b = 3;
myObject.b; // undefined
```

- **密封**:
  `Object.seal(..) `会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用`Object.preventExtensions(..) `并把所有现有属性标记为`configurable:false`。所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。

- **冻结**
  `Object.freeze(..)` 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用`Object.seal(..) `并把所有“数据访问”属性标记为`writable:false`，这样就无法修改它们的值。

### 存在性

可以在不访问属性值的情况下判断对象中是否存在这个属性：

```js
var myObject = {
  a: 2,
};
"a" in myObject; // true
"b" in myObject; // false
myObject.hasOwnProperty("a"); // true
myObject.hasOwnProperty("b"); // false
```

`in `操作符会检查属性是否在对象及其`[[Prototype]]`原型链中。相比之下，`hasOwnProperty(..)` 只会检查属性是否在`myObject` 对象中，不会检查`[[Prototype]] `链。

**枚举**：
在**数组**上应用`for..in` 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在**对象**上应用`for..in` 循环，如果要遍历数组就使用传统的`for `循环来遍历数值索引。

```js
var myObject = {};
Object.defineProperty(
  myObject,
  "a",
  // 让a 像普通属性一样可以枚举
  { enumerable: true, value: 2 }
);
Object.defineProperty(
  myObject,
  "b",
  // 让b 不可枚举
  { enumerable: false, value: 3 }
);
myObject.propertyIsEnumerable("a"); // true
myObject.propertyIsEnumerable("b"); // false
Object.keys(myObject); // ["a"]
Object.getOwnPropertyNames(myObject); // ["a", "b"]
```

`propertyIsEnumerable(..) `会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足`enumerable:true`。
`Object.keys(..)` 会返回一个数组，包含所有可枚举属性，`Object.getOwnPropertyNames(..)`会返回一个数组，包含所有属性，无论它们是否可枚举。
`in`和`hasOwnProperty(..)` 的区别在于是否查找 [[Prototype]] 链，然而，`Object.keys(..)`和`Object.getOwnPropertyNames(..)` 都只会查找对象直接包含的属性。

**小结**：

- `hasOwnProperty(..)` `Object.keys(..)`(返回属性名组成的数组) `Object.getOwnPropertyNames(..)`(返回属性名组成的数组) 都只会查找对象**直接包含**的属性
- `in` 会查找 **[[Prototype]]** 链
- `propertyIsEnumerable` 检查给定的属性名是否直接存在于对象中并且满足`enumerable:true`

### 遍历

ES5 中增加了一些数组的辅助迭代器，包括`forEach(..)`、`every(..)`和`some(..)`。每种辅助迭代器都可以接受一个**回调函数**并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。

- `forEach(..)` 会遍历数组中的所有值并忽略回调函数的返回值
- `every(..)` 会一直运行直到回调函数返回`false`（或者“假”值）
- `some(..)` 会一直运行直到回调函数返回 `true`（或者“真”值）
  `every(..)` 和`some(..)` 中特殊的返回值和普通`for`循环中的`break`语句类似，它们会提前终止遍历。`forEach(..)` 中 `break` 无效！！！

ES6 增加了一种用来遍历数组的`for..of` 循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：

```js
var myArray = [1, 2, 3];
for (var v of myArray) {
  console.log(v);
}
// 1
// 2
// 3
```
