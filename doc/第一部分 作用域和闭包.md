# 第一部分 作用域和闭包

### 第 1 章 作用域是什么

- **作用域规则**:
  当一个**块**或**函数**嵌套在另一个块或函数中时，就发生了**作用域的嵌套**。因此，在当前作用域中无法找到某个变量时，引擎就会在**外层嵌套**的作用域中继续查找，直到找到该变量，或抵达**最外层的作用域**（也就是**全局作用域**）为止。

```js
function foo(a) {
  console.log(a + b);
}
var b = 2;
foo(2); // 4
```

- **LHS & RHS**:
  作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行**赋值**，那么就会使用**LHS 查询**；如果目的是**获取变量的值**，`console.log(a)`就会使用**RHS 查询**。

- **编译与解析过程**：
  JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像`var a = 2` 这样的声明会被分解成两个独立的步骤：

1. 首先，`var a` 在其作用域中声明**新变量**(代码执行前进行)。
2. 接下来，`a = 2` 会**查询**（LHS 查询）变量`a` 并对其进行赋值。

### 第 2 章 词法作用域

词法作用域意味着作用域是由**书写代码时函数声明的位置**来决定的。编译的词法分析阶段基本能够知道**全部标识符**（变量、函数）在哪里以及是**如何声明**的，从而能够预测在执行过程中如何对它们进行**查找**。
**欺骗词法作用域不推荐使用**：`JavaScript` 中有两个机制可以“欺骗”词法作用域：`eval(..)` 和`with`。运行时修改了词法作用域。（例如属性遮蔽）
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

### 第 3 章 函数作用域和块作用域

**函数作用域**: 函数是`JavaScript`中最常见的作用域单元。本质上，声明在一个**函数内部的变量**或**函数**会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。
**e.g**

```js
function foo() {
  var a = 2;
  function bar() {}
}
window.a;
// undefined
window.bar();
// Uncaught TypeError: window.bar is not a function
```

**块级作用域**: 函数不是唯一的作用域单元。**块作用域**指的是变量和函数不仅可以属于所处的作用域，也可以属于**某个代码块**（通常指{ .. } 内部）。**从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。**
**e.g**

```js
try {
} catch (error) {
  // 块作用域
  function f() {
    console.log("f");
  }
  var a = 1;
}
window.a;
// undefined
window.f();
// Uncaught TypeError: window.f is not a function
```

ES6 中**变量块级作用域**的产生：
一般来说，在 {...}中通过 `var`声明的变量属于全局属性，挂在全局作用域上：

```js
if (true) {
  // 不会有块级作用域
  function f() {
    console.log("f");
  }
  var a = 10;
}
window.a;
// 10
window.f();
// f
```

ES6 中，可以通过`let`和`const`来产生**变量的块级作用域**：

```js
if (true) {
  // 有块级作用域
  let k = 10;
}
undefined;
window.k;
//undefined
```

**通过立即自执行函数可以隐蔽变量以及函数**：

```js
(function () {
  var a = 1;
  function bar() {
    console.log("bar");
  }
})();
```

### 第 4 章 提升

第 1 章讲过，`var a = 1`被`JavaScript`引擎看作两个过程：

- 1、编译阶段的任务,查找所有的声明 `var a`
- 2、执行阶段的任务，将变量关联作用域 `a = 1`

**函数与变量提升**：
所有的声明（变量和函数）都会被“移动”到各自作用域的**最顶端**，这个过程被称为**提升**, 并且，**函数提升优先于变量提升**。
e.g

```js
foo(); // 1
var foo;
function foo() {
  console.log(1);
}
foo = function () {
  console.log(2);
};
```

会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：

```js
function foo() {
  console.log(1);
}
foo(); // 1
foo = function () {
  console.log(2);
};
```

注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。**但出现在后面的函数声明还是可以覆盖前面的(函数声明)。**

一个普通块内部的函数声明通常会被提升到所在作用域的顶部:
e.g

```js
foo(); // "b"
var a = true;
if (a) {
  function foo() {
    console.log("a");
  }
} else {
  function foo() {
    console.log("b");
  }
}
```

**注意：函数表达式不会提升**
e.g

```js
// 函数不提升
f();
var f = function () {
  console.log("f");
};

// 函数提升
f();
function f() {
  console.log("f");
}
//TypeError: f is not a function
```

### 第 5 章 作用域闭包

**闭包**：当函数可以**记住并访问**所在的**词法作用域**时，就产生了闭包，即使函数是在当前词法作用域之外执行。
**循环与闭包**：
下面来看一个经典的问题：

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

运行时会以每秒一次的频率输出**五次 6**
使用 **IIFE** 进行改造,创造出作用域：

```js
for (var i = 1; i <= 5; i++) {
  (function () {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  })();
}
```

运行结果还是一样，**五次 6**
**如果作用域是空的**，那么仅仅将它们进行封闭是不够的。
每次迭代，使用使用变量`j`来存储，形成独立的**词法作用域**

```js
for (var i = 1; i <= 5; i++) {
  (function () {
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })();
}
```

或者

```js
for (var i = 1; i <= 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

运行结果为**每秒增加 1 输出**
使用变量的块作用域解决：

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

**模块模式**：

- 必须有**外部的封闭函数**，该函数必须至少被调用一次（每次调用都会创建一个新的模块
  实例）。
- 封闭函数必须**返回至少一个内部函数**，这样内部函数才能在私有作用域中形成闭包，并
  且可以访问或者修改私有的状态。

```js
function CoolModule() {
  // 私有变量
  var something = "cool";
  var another = [1, 2, 3];

  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join(" ! "));
  }
  return {
    doSomething: doSomething,
    doAnother: doAnother,
  };
}
var foo = CoolModule();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

#### 现代的模块机制:

```js
var MyModules = (function Manager() {
  var modules = {};
  /**
   * @param {String} name 函数名
   * @param {Array} deps 引用的（函数作用域）的函数名
   * @param {Function} impl  函数
   */
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }
  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get,
  };
})();

MyModules.define("bar", [], function () {
  function hello(who) {
    return "Let me introduce: " + who;
  }
  return {
    hello: hello,
  };
});

MyModules.define("foo", ["bar"], function (bar) {
  var hungry = "hippo";
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }
  return {
    awesome: awesome,
  };
});

var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(bar.hello("hippo"));
// Let me introduce: hippo
foo.awesome();
// LET ME INTRODUCE: HIPPO
```
