# 第四部分 混合对象“类”

### 混入

mixin | extend

```js
// 非常简单的mixin(..) 例子:
function mixin(sourceObj, targetObj) {
  for (var key in sourceObj) {
    // 只会在不存在的情况下复制
    if (!(key in targetObj)) {
      targetObj[key] = sourceObj[key];
    }
  }
  return targetObj;
}
var Vehicle = {
  engines: 1,
  ignition: function () {
    console.log("Turning on my engine.");
  },
  drive: function () {
    // this 指向 Vehicle
    this.ignition();
    console.log("Steering and moving forward!");
  },
};
var Car = mixin(Vehicle, {
  wheels: 4,
  drive: function () {
    // this 绑定到 Car 上
    Vehicle.drive.call(this);
    console.log("Rolling on all " + this.wheels + " wheels!");
  },
});
```

```js
// 另一种混入函数，可能有重写风险
function mixin(sourceObj, targetObj) {
  for (var key in sourceObj) {
    targetObj[key] = sourceObj[key];
  }
  return targetObj;
}
var Vehicle = {
  // ...
};
// 首先创建一个空对象并把Vehicle 的内容复制进去
var Car = mixin(Vehicle, {});
// 然后把新内容复制到Car 中
mixin(
  {
    wheels: 4,
    drive: function () {
      // ...
    },
  },
  Car
);
```

### 显式混入模式的一种变体被称为“寄生继承”

```js
// “传统的JavaScript 类”Vehicle
function Vehicle() {
  this.engines = 1;
}

Vehicle.prototype.ignition = function () {
  console.log("Turning on my engine.");
};

Vehicle.prototype.drive = function () {
  this.ignition();
  console.log("Steering and moving forward!");
};

// “寄生类” Car
function Car() {
  // 首先，car 是一个Vehicle
  var car = new Vehicle();

  // 接着我们对car 进行定制
  car.wheels = 4;

  // 保存到Vehicle::drive() 的特殊引用
  var vehDrive = car.drive;

  // 重写Vehicle::drive()
  car.drive = function () {
    vehDrive.call(this);
    console.log("Rolling on all " + this.wheels + " wheels!");
    return car;
  };
}
var myCar = new Car();
myCar.drive();
// 发动引擎。
// 手握方向盘！
// 全速前进！
```

### 隐式混入
虽然这类技术利用了this 的重新绑定功能，但是Something.cool.call( this ) 仍然无法
变成相对（而且更灵活的）引用，所以使用时千万要小心。通常来说，尽量避免使用这样
的结构，以保证代码的整洁和可维护性。
```js
var Something = {
  cool: function () {
    this.greeting = "Hello World";
    this.count = this.count ? this.count + 1 : 1;
  },
};
Something.cool(); 
Something.greeting; // "Hello World"
Something.count; // 1
var Another = {
  cool: function () {
    // 隐式把Something 混入Another
    Something.cool.call(this);
  },
};
Another.cool();
Another.greeting; // "Hello World"
Another.count; // 1 （count 不是共享状态）
```
